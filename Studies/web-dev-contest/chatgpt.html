<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Paint — single file</title>
<style>
  :root{
    --bg:#111;
    --panel:#0f1720;
    --muted:#94a3b8;
    --accent:#38bdf8;
    --card:#0b1220;
  }
  html,body{height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,-apple-system;}
  body{background:linear-gradient(180deg,#071021 0%, #07101b 60%); color:#e6eef8; display:flex; flex-direction:column; gap:12px; padding:14px;}
  h1{font-size:16px;margin:0 0 4px 0}
  .app {
    display:grid;
    grid-template-columns:320px 1fr;
    gap:14px;
    align-items:start;
    max-width:1200px;
    width:100%;
    margin:0 auto;
  }

  .panel {
    background:linear-gradient(180deg,var(--panel),#05101a);
    border-radius:10px;
    padding:12px;
    box-shadow:0 6px 18px rgba(2,6,23,.6);
    min-height:480px;
  }

  .controls { display:flex; flex-direction:column; gap:10px; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  label{color:var(--muted); font-size:12px}
  button,select{background:transparent;border:1px solid #1f2b36;padding:8px;border-radius:8px;color:var(--muted); cursor:pointer}
  button:hover{border-color:var(--accent); color:#dff6ff}
  input[type="range"]{width:140px}
  .palette { display:flex; gap:6px; flex-wrap:wrap; }
  .sw { width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.06); cursor:pointer }
  .active { outline:3px solid rgba(56,189,248,.18); box-shadow:0 2px 6px rgba(56,189,248,.06) }
  .toolbar { display:flex; gap:6px; flex-wrap:wrap }
  .big { padding:10px 12px; font-weight:600; color:#e6f8ff; border-color:transparent; background:linear-gradient(90deg,#123047,#0b2733); }
  .canvas-wrap { background:var(--card); border-radius:10px; padding:10px; display:flex; flex-direction:column; gap:10px; box-shadow: 0 10px 30px rgba(2,6,23,.6);}
  #board { border-radius:6px; background:white; touch-action:none; display:block; max-width:100%; width:100%; height:640px; box-shadow:inset 0 0 0 1px rgba(0,0,0,.06);}
  .small-muted{font-size:12px;color:var(--muted)}
  .kbd { padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,.04); background:#071827; font-size:12px }
  footer{font-size:12px;color:var(--muted); text-align:center; margin-top:6px}
  input[type="number"]{width:72px;padding:6px;border-radius:6px;border:1px solid #123; background:transparent; color:var(--muted)}
  .btn-icon{display:inline-flex;align-items:center;gap:6px}
</style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Mini Paint</h1>
      <div class="controls">
        <div>
          <div class="row">
            <label class="small-muted">Tool</label>
          </div>
          <div class="row toolbar" style="margin-top:6px">
            <button id="brushBtn" class="big btn-icon">Brush</button>
            <button id="eraserBtn" class="btn-icon">Eraser</button>
            <button id="clearBtn" class="btn-icon">Clear</button>
          </div>
          <div class="small-muted" style="margin-top:6px">Shortcuts: <span class="kbd">Ctrl+Z</span> undo, <span class="kbd">Ctrl+Y</span> redo</div>
        </div>

        <div>
          <label>Brush texture</label>
          <div class="row" style="margin-top:6px">
            <select id="textureSelect">
              <option value="solid">Solid round</option>
              <option value="splatter">Splatter</option>
              <option value="chalk">Chalk / smudge</option>
            </select>
            <label class="small-muted" style="margin-left:6px">Brush size</label>
            <input id="brushSize" type="range" min="1" max="120" value="24">
            <span id="brushSizeVal" class="small-muted">24</span>
          </div>
        </div>

        <div>
          <label>Eraser size</label>
          <div class="row" style="margin-top:6px">
            <input id="eraserSize" type="range" min="4" max="200" value="48">
            <span id="eraserSizeVal" class="small-muted">48</span>
          </div>
        </div>

        <div>
          <label>Color</label>
          <div class="row" style="margin-top:6px; align-items:center;">
            <input id="colorPicker" type="color" value="#0ea5e9">
            <div class="palette" id="palette" style="margin-left:6px;">
              <!-- sample swatches -->
            </div>
          </div>
        </div>

        <div>
          <label>Canvas size (px)</label>
          <div class="row" style="margin-top:6px">
            <input id="canvasW" type="number" min="200" max="4000" value="1000"> ×
            <input id="canvasH" type="number" min="200" max="4000" value="640">
            <button id="resizeBtn" style="margin-left:8px">Resize</button>
          </div>
          <div class="small-muted" style="margin-top:6px">Resize preserves current drawing and scales it.</div>
        </div>

        <div>
          <label>Undo / Redo</label>
          <div class="row" style="margin-top:6px">
            <button id="undoBtn">Undo</button>
            <button id="redoBtn">Redo</button>
            <button id="snapshotBtn" title="Save snapshot">Snapshot</button>
          </div>
        </div>

        <div>
          <label>Export / Import</label>
          <div class="row" style="margin-top:6px">
            <button id="savePng">Save PNG</button>
            <input id="fileIn" type="file" accept="image/*" style="display:none">
            <button id="loadBtn">Load Image</button>
          </div>
        </div>

      </div>
    </div>

    <div class="canvas-wrap">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <div>
          <div class="small-muted">Canvas</div>
        </div>
        <div class="row">
          <div class="small-muted">Mode:</div>
          <div id="modeLabel" style="min-width:90px; text-align:right; font-weight:600">Brush</div>
        </div>
      </div>

      <canvas id="board" width="1000" height="640"></canvas>
      <footer>Made with HTML Canvas — three textures, colors, eraser, resize, undo/redo.</footer>
    </div>
  </div>

<script>
(() => {
  // Elements
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const brushBtn = document.getElementById('brushBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const clearBtn = document.getElementById('clearBtn');
  const colorPicker = document.getElementById('colorPicker');
  const paletteEl = document.getElementById('palette');
  const brushSizeEl = document.getElementById('brushSize');
  const brushSizeVal = document.getElementById('brushSizeVal');
  const eraserSizeEl = document.getElementById('eraserSize');
  const eraserSizeVal = document.getElementById('eraserSizeVal');
  const textureSelect = document.getElementById('textureSelect');
  const modeLabel = document.getElementById('modeLabel');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const snapshotBtn = document.getElementById('snapshotBtn');
  const savePng = document.getElementById('savePng');
  const fileIn = document.getElementById('fileIn');
  const loadBtn = document.getElementById('loadBtn');
  const canvasW = document.getElementById('canvasW');
  const canvasH = document.getElementById('canvasH');
  const resizeBtn = document.getElementById('resizeBtn');

  // Palette setup
  const sampleColors = ['#0ea5e9','#06b6d4','#ef4444','#f97316','#f59e0b','#10b981','#7c3aed','#e11d48','#111827','#ffffff','#000000','#f8fafc'];
  sampleColors.forEach(c => {
    const sw = document.createElement('div');
    sw.className = 'sw';
    sw.style.background = c;
    sw.title = c;
    sw.onclick = () => { colorPicker.value = rgbToHex(c); };
    paletteEl.appendChild(sw);
  });

  function rgbToHex(c){ return c; } // already hex for our samples

  // State
  let tool = 'brush'; // 'brush' or 'eraser'
  let drawing = false;
  let last = null;
  let brushSize = +brushSizeEl.value;
  let eraserSize = +eraserSizeEl.value;
  let color = colorPicker.value;
  let texture = textureSelect.value;
  let history = [];
  let future = [];
  const MAX_HISTORY = 30;

  // HiDPI scaling
  function updateCanvasSize(w, h) {
    // create a temporary image to preserve current content
    const temp = document.createElement('canvas');
    temp.width = canvas.width;
    temp.height = canvas.height;
    temp.getContext('2d').drawImage(canvas,0,0);

    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.round(w));
    canvas.height = Math.max(1, Math.round(h));
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';

    // draw scaled image onto new canvas (fit)
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(temp, 0, 0, temp.width, temp.height, 0, 0, canvas.width, canvas.height);
    pushHistory(); // snapshot after resize
  }

  // initial setup values
  updateCanvasSize(+canvasW.value, +canvasH.value);
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.fillStyle = 'white';
  // fill white background initially
  ctx.save();
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();
  pushHistory();

  // Helpers: history via dataURL (keeps memory moderate)
  function pushHistory() {
    try {
      if (history.length >= MAX_HISTORY) history.shift();
      history.push(canvas.toDataURL('image/png'));
      // clear redo stack when new action added
      future = [];
      updateButtons();
    } catch(e){ console.warn('history push fail', e); }
  }
  function undo() {
    if (history.length <= 1) return;
    const last = history.pop();
    future.push(last);
    const prev = history[history.length - 1];
    restoreFromDataURL(prev);
    updateButtons();
  }
  function redo() {
    if (!future.length) return;
    const next = future.pop();
    history.push(next);
    restoreFromDataURL(next);
    updateButtons();
  }
  function restoreFromDataURL(dataUrl) {
    const img = new Image();
    img.onload = () => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    };
    img.src = dataUrl;
  }
  function updateButtons() {
    undoBtn.disabled = history.length <= 1;
    redoBtn.disabled = future.length === 0;
  }

  // Drawing primitives for textured brushes
  function drawDot(x,y, size, color, textureType, ctxRef) {
    const c = ctxRef || ctx;
    if (textureType === 'solid') {
      c.beginPath();
      c.fillStyle = color;
      c.arc(x,y,size/2,0,Math.PI*2);
      c.fill();
    } else if (textureType === 'splatter') {
      // central core
      c.save();
      c.globalAlpha = 0.85;
      c.fillStyle = color;
      c.beginPath();
      c.arc(x,y,(size/2)*0.6,0,Math.PI*2);
      c.fill();
      c.globalAlpha = 1;
      // splatter points
      const count = Math.max(8, Math.round(size/6)*2);
      for (let i=0;i<count;i++){
        const ang = Math.random()*Math.PI*2;
        const r = Math.random()*(size/1.2);
        const sx = x + Math.cos(ang)*r;
        const sy = y + Math.sin(ang)*r;
        const s = Math.random()*Math.max(1,size/8);
        c.beginPath();
        c.globalAlpha = 0.6*Math.random();
        c.arc(sx,sy,s,0,Math.PI*2);
        c.fill();
      }
      c.restore();
    } else if (textureType === 'chalk') {
      // chalk-like: many semi-transparent jittered strokes
      c.save();
      for (let i=0;i<8;i++){
        const jitterX = x + (Math.random()-0.5)*size*0.6;
        const jitterY = y + (Math.random()-0.5)*size*0.6;
        c.globalAlpha = 0.12 + Math.random()*0.18;
        c.beginPath();
        c.fillStyle = color;
        c.arc(jitterX, jitterY, Math.max(1, size/3 * Math.random()), 0, Math.PI*2);
        c.fill();
      }
      c.restore();
    }
  }

  // Line drawing using many dots between points
  function strokeBetween(x0,y0,x1,y1, size, color, textureType, ctxRef) {
    const dx = x1 - x0;
    const dy = y1 - y0;
    const dist = Math.hypot(dx,dy);
    const step = Math.max(1, size / 6);
    const steps = Math.ceil(dist/step);
    for (let i=0;i<=steps;i++) {
      const t = i/steps;
      const x = x0 + dx*t;
      const y = y0 + dy*t;
      drawDot(x,y,size,color,textureType, ctxRef);
    }
  }

  // Mouse / Touch handling
  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    if (e.touches && e.touches[0]) {
      return { x: (e.touches[0].clientX - rect.left) * (canvas.width / rect.width), y: (e.touches[0].clientY - rect.top) * (canvas.height / rect.height) };
    } else {
      return { x: (e.clientX - rect.left) * (canvas.width / rect.width), y: (e.clientY - rect.top) * (canvas.height / rect.height) };
    }
  }

  function startDraw(e) {
    e.preventDefault();
    drawing = true;
    last = getPos(e);
    // prepare for erase mode
    if (tool === 'eraser') {
      // use destination-out so transparency is created
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
    } else {
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
    }
    // draw immediate point
    if (tool === 'eraser') {
      strokeBetween(last.x, last.y, last.x, last.y, eraserSize, null, 'solid');
    } else {
      strokeBetween(last.x, last.y, last.x, last.y, brushSize, color, texture);
    }
  }

  function moveDraw(e) {
    if (!drawing) return;
    e.preventDefault();
    const p = getPos(e);
    if (tool === 'eraser') {
      strokeBetween(last.x, last.y, p.x, p.y, eraserSize, null, 'solid');
    } else {
      strokeBetween(last.x, last.y, p.x, p.y, brushSize, color, texture);
    }
    last = p;
  }

  function endDraw(e) {
    if (!drawing) return;
    drawing = false;
    ctx.restore();
    pushHistory();
  }

  // Event listeners
  canvas.addEventListener('mousedown', startDraw);
  canvas.addEventListener('touchstart', startDraw, {passive:false});
  window.addEventListener('mousemove', moveDraw);
  window.addEventListener('touchmove', moveDraw, {passive:false});
  window.addEventListener('mouseup', endDraw);
  window.addEventListener('touchend', endDraw);

  // Tools UI
  brushBtn.onclick = () => { tool='brush'; modeLabel.textContent = 'Brush'; brushBtn.classList.add('active'); eraserBtn.classList.remove('active'); };
  eraserBtn.onclick = () => { tool='eraser'; modeLabel.textContent='Eraser'; eraserBtn.classList.add('active'); brushBtn.classList.remove('active'); };
  brushBtn.classList.add('active');

  clearBtn.onclick = () => {
    if (!confirm('Clear canvas?')) return;
    ctx.save();
    ctx.fillStyle = '#ffffff';
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
    pushHistory();
  };

  colorPicker.oninput = (e) => { color = e.target.value; };
  brushSizeEl.oninput = (e) => { brushSize = +e.target.value; brushSizeVal.textContent = brushSize; };
  eraserSizeEl.oninput = (e) => { eraserSize = +e.target.value; eraserSizeVal.textContent = eraserSize; };
  textureSelect.onchange = (e) => { texture = e.target.value; };

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;
  snapshotBtn.onclick = pushHistory;

  // Save / Load
  savePng.onclick = () => {
    const a = document.createElement('a');
    a.download = 'mini-paint.png';
    a.href = canvas.toDataURL('image/png');
    a.click();
  };
  loadBtn.onclick = () => fileIn.click();
  fileIn.onchange = (ev) => {
    const f = ev.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = (r) => {
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        pushHistory();
      };
      img.src = r.target.result;
    };
    reader.readAsDataURL(f);
  };

  // Resize canvas
  resizeBtn.onclick = () => {
    const w = parseInt(canvasW.value,10) || canvas.width;
    const h = parseInt(canvasH.value,10) || canvas.height;
    if (!confirm(`Resize canvas to ${w}×${h}? (current content will be scaled to new size)`)) return;
    updateCanvasSize(w,h);
  };

  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
    if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase()==='z'))) { e.preventDefault(); redo(); }
    if (e.key === 'e') { tool='eraser'; modeLabel.textContent='Eraser'; eraserBtn.classList.add('active'); brushBtn.classList.remove('active'); }
    if (e.key === 'b') { tool='brush'; modeLabel.textContent='Brush'; brushBtn.classList.add('active'); eraserBtn.classList.remove('active'); }
  });

  // Basic analytics: none. Just safety.
  function preventScroll(e){ if (e.target===canvas) e.preventDefault(); }
  document.body.addEventListener('touchmove', preventScroll, {passive:false});

  // when drawing with mouse wheel or pointerlock? optional — not implemented

  // initialize buttons
  updateButtons();

  // small UI polish for mobile: prevent context menu on long press
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());

  // Give instant feedback: display sizes etc.
  brushSizeVal.textContent = brushSize;
  eraserSizeVal.textContent = eraserSize;

  // Touch support tested in common browsers.

  // Expose small API in window for debugging (optional)
  window.miniPaint = {
    pushHistory, undo, redo, canvas, ctx
  };

})();
</script>
</body>
</html>
